<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ‰ãƒ©ã‚´ãƒ³ã‚¯ã‚¨ã‚¹ãƒˆé¢¨RPG</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'MS Gothic', monospace; background: #000; display: flex; justify-content: center; align-items: center; min-height: 100vh; color: #fff; }
        #game-container { width: 800px; background: #000; border: 4px solid #fff; }
        #game-screen { width: 100%; height: 480px; background: #000; position: relative; overflow: hidden; }
        #field-container { position: absolute; top: 0; left: 0; transition: transform 0.1s; }
        #field { display: grid; grid-template-columns: repeat(100, 30px); grid-template-rows: repeat(100, 30px); }
        .tile { width: 30px; height: 30px; }
        .grass { background: #0a0; }
        .forest { background: #050; }
        .water { background: #05f; }
        .mountain { background: #864; }
        .desert { background: #ed9; }
        .snow { background: #eef; }
        .swamp { background: #583; }
        .bridge { background: #963; }
        .cave { background: #333; }
        .town { background: #fa0; }
        .shop { background: #f0a; }
        #player { position: absolute; width: 30px; height: 30px; background: #ff0; border-radius: 50%; transition: all 0.1s; box-shadow: 0 0 10px rgba(255,255,0,0.5); }
        #message-box { height: 120px; background: #000; border-top: 4px solid #fff; padding: 15px; font-size: 18px; line-height: 1.6; }
        #status { display: flex; justify-content: space-between; padding: 10px 15px; background: #000; border-top: 2px solid #fff; font-size: 16px; }
        .status-group { display: flex; gap: 20px; }
        .battle-screen { width: 100%; height: 100%; background: #000; display: none; flex-direction: column; justify-content: space-around; align-items: center; padding: 30px; }
        .enemy-group { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin: 20px 0; }
        .enemy-container { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 10px; border: 2px solid transparent; border-radius: 5px; }
        .enemy-container.selected { border-color: #ff0; background: rgba(255, 255, 0, 0.2); }
        .enemy-container.dead { opacity: 0.3; cursor: default; }
        .enemy-sprite { font-size: 60px; }
        .enemy-number { font-size: 14px; color: #aaa; }
        .battle-info { text-align: center; font-size: 20px; min-height: 60px; }
        .battle-commands { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 400px; }
        button { padding: 15px; font-size: 18px; font-family: 'MS Gothic', monospace; background: #000; color: #fff; border: 3px solid #fff; cursor: pointer; }
        button:hover:not(:disabled) { background: #333; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #000; border: 4px solid #fff; padding: 30px; min-width: 500px; max-height: 80%; overflow-y: auto; z-index: 100; }
        .menu h2, .menu h3 { margin-bottom: 20px; text-align: center; }
        .shop-item, .magic-item { display: flex; justify-content: space-between; padding: 10px; border: 2px solid #fff; margin-bottom: 10px; cursor: pointer; }
        .shop-item:hover, .magic-item:hover { background: #333; }
        .magic-item.disabled { opacity: 0.5; cursor: not-allowed; }
        .status-effect { color: #f0f; font-size: 14px; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-screen">
            <div id="field-container">
                <div id="field"></div>
                <div class="menu" id="shop-menu">
                <h2 id="shop-title">ã¿ã›</h2>
                <div id="shop-items"></div>
                <button onclick="game.closeShop()">ã‚„ã‚ã‚‹</button>
            </div>
            <div class="menu" id="inn-menu">
                <h2>ã‚„ã©ã‚„</h2>
                <p style="margin-bottom: 20px;">ä¸€æ™© 50ã‚´ãƒ¼ãƒ«ãƒ‰ã§ã™ã€‚</p>
                <button onclick="game.stayAtInn()">ã¨ã¾ã‚‹</button>
                <button onclick="game.closeInn()">ã‚„ã‚ã‚‹</button>
            </div>
        </div>
            <div id="player"></div>
            <div class="battle-screen" id="battle-screen">
                <div class="enemy-group" id="enemy-group"></div>
                <div class="battle-info" id="battle-info"></div>
                <div class="menu" id="magic-menu">
                    <h3>ã¾ã»ã†</h3>
                    <div id="magic-list"></div>
                    <button onclick="game.closeMagicMenu()">ã‚‚ã©ã‚‹</button>
                </div>
                <div class="menu" id="item-menu">
                    <h3>ã©ã†ã</h3>
                    <div id="item-list"></div>
                    <button onclick="game.closeItemMenu()">ã‚‚ã©ã‚‹</button>
                </div>
                <div class="battle-commands" id="battle-commands">
                    <button onclick="game.attack()">ãŸãŸã‹ã†</button>
                    <button onclick="game.openMagicMenu()">ã¾ã»ã†</button>
                    <button onclick="game.openItemMenu()">ã©ã†ã</button>
                    <button onclick="game.runAway()">ã«ã’ã‚‹</button>
                </div>
            </div>
        </div>
        <div id="message-box">ã‚ˆã†ã“ãã€å‹‡è€…ã‚ˆï¼<br>ä¸–ç•Œã‚’å†’é™ºã—ã‚ˆã†ï¼</div>
        <div id="status">
            <div class="status-group">
                <span>LV: <span id="level">1</span></span>
                <span>HP: <span id="hp">30</span>/<span id="maxHp">30</span></span>
                <span>MP: <span id="mp">10</span>/<span id="maxMp">10</span></span>
            </div>
            <div class="status-group">
                <span>EXP: <span id="exp">0</span></span>
                <span>G: <span id="gold">100</span></span>
            </div>
        </div>
    </div>

    <script>
        const game = {
            player: {
                x: 50, y: 50, hp: 30, maxHp: 30, mp: 10, maxMp: 10, level: 1, exp: 0, gold: 100,
                attack: 5, defense: 3, poisoned: false,
                equipment: {
                    weapon: null,
                    armor: null,
                    helmet: null,
                    gloves: null,
                    boots: null
                },
                inventory: {'ã‚„ããã†': 3, 'ã©ãã‘ã—ãã†': 1}
            },
            inBattle: false,
            currentEnemies: [],
            selectedEnemyIndex: 0,
            commandsLocked: false,
            currentShop: null,
            mapSize: 100,
            viewportWidth: 16,
            viewportHeight: 16,
            map: [],
            audioContext: null,
            currentMusic: null,
            musicEnabled: true,

            enemies: [
                {name:'ã‚¹ãƒ©ã‚¤ãƒ ',hp:8,attack:3,defense:1,exp:5,gold:10,sprite:'ğŸ’§',poison:false,drops:[{item:'ã‚„ããã†',chance:0.3}]},
                {name:'ã“ã†ã‚‚ã‚Š',hp:7,attack:4,defense:1,exp:6,gold:8,sprite:'ğŸ¦‡',poison:false,drops:[{item:'ã‚„ããã†',chance:0.2}]},
                {name:'ãŠãŠã­ãšã¿',hp:9,attack:3,defense:2,exp:5,gold:12,sprite:'ğŸ€',poison:false,drops:[{item:'ã©ãã‘ã—ãã†',chance:0.2}]},
                {name:'ã‚³ãƒœãƒ«ãƒ‰',hp:10,attack:4,defense:2,exp:7,gold:15,sprite:'ğŸ‘¹',poison:false,drops:[{item:'ã²ã®ãã®ã¼ã†',chance:0.1,type:'weapon',attack:2}]},
                {name:'ãŒã„ã“ã¤',hp:12,attack:5,defense:3,exp:8,gold:18,sprite:'ğŸ’€',poison:false,drops:[{item:'ã‹ã‚ã®ã¼ã†ã—',chance:0.15,type:'helmet',defense:1}]},
                {name:'ã‚´ãƒ–ãƒªãƒ³',hp:15,attack:6,defense:2,exp:12,gold:25,sprite:'ğŸ‘º',poison:false,drops:[{item:'ã©ã†ã®ã¤ã‚‹ã',chance:0.1,type:'weapon',attack:5}]},
                {name:'ã‚´ãƒ¼ã‚¹ãƒˆ',hp:13,attack:7,defense:3,exp:13,gold:28,sprite:'ğŸ‘»',poison:false,drops:[{item:'ã‚„ããã†',chance:0.25}]},
                {name:'ã‚¿ã‚¤ã‚¬ãƒ¼',hp:18,attack:8,defense:2,exp:15,gold:30,sprite:'ğŸ¯',poison:false,drops:[{item:'ã¡ã‹ã‚‰ã®ãŸã­',chance:0.15}]},
                {name:'ã¨ã†ãã',hp:16,attack:7,defense:4,exp:14,gold:35,sprite:'ğŸ¥·',poison:false,drops:[{item:'gold',amount:50,chance:0.2}]},
                {name:'ãŒã„ã“ã¤æˆ¦å£«',hp:20,attack:9,defense:5,exp:16,gold:32,sprite:'âš”ï¸',poison:false,drops:[{item:'ã¦ã¤ã®ã‹ã¶ã¨',chance:0.12,type:'helmet',defense:3}]},
                {name:'ã‚¾ãƒ³ãƒ“',hp:22,attack:8,defense:3,exp:15,gold:28,sprite:'ğŸ§Ÿ',poison:true,drops:[{item:'ã©ãã‘ã—ãã†',chance:0.3}]}
            ],

            npcs: [
                {name:'æ—…ã®å•†äºº',sprite:'ğŸ§™',message:'ã“ã®å…ˆã«ã¯å¼·æ•µãŒå¾…ã£ã¦ã„ã‚‹ãã€‚è£…å‚™ã‚’æ•´ãˆã¦ã„ãã¨ã„ã„ã€‚'},
                {name:'è€è³¢è€…',sprite:'ğŸ‘´',message:'ãƒ¬ãƒ™ãƒ«5ã«ãªã‚‹ã¨æ–°ã—ã„é­”æ³•ã‚’è¦šãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã ã€‚'},
                {name:'å†’é™ºè€…',sprite:'ğŸ—¡ï¸',message:'æ£®ã«ã¯ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒå¤šã„ãŒã€çµŒé¨“å€¤ç¨¼ãã«ã¯ã‚‚ã£ã¦ã“ã„ã ãœï¼'},
                {name:'æ‘äºº',sprite:'ğŸ‘¨',message:'å®¿å±‹ã§ä¼‘ã‚ã°HPã¨MPãŒå…¨å›å¾©ã™ã‚‹ã‚ˆã€‚'},
                {name:'åŸéŠè©©äºº',sprite:'ğŸ­',message:'ä¼èª¬ã®è£…å‚™ã¯å¼·ã„æ•µãŒæŒã£ã¦ã„ã‚‹ã‚‰ã—ã„ãã€‚'}
            ],

            spells: {
                'ãƒ•ã‚¡ã‚¤ã‚¢': {mp:3, power:15, target:'single'},
                'ã‚¤ã‚ª': {mp:8, power:20, target:'all'}
            },

            shops: {
                'weapon_shop_1': {
                    name: 'ã¶ãã‚„ï¼ˆåˆç´šï¼‰',
                    items: [
                        {name: 'ã²ã®ãã®ã¼ã†', attack: 2, price: 50, type: 'weapon'},
                        {name: 'ã©ã†ã®ã¤ã‚‹ã', attack: 5, price: 150, type: 'weapon'}
                    ]
                },
                'armor_shop_1': {
                    name: 'ã¼ã†ãã‚„ï¼ˆåˆç´šï¼‰',
                    items: [
                        {name: 'ã¬ã®ã®ãµã', defense: 2, price: 50, type: 'armor'},
                        {name: 'ã‹ã‚ã®ã¼ã†ã—', defense: 1, price: 40, type: 'helmet'}
                    ]
                },
                'weapon_shop_2': {
                    name: 'ã¶ãã‚„ï¼ˆä¸­ç´šï¼‰',
                    items: [
                        {name: 'ã¯ãŒã­ã®ã¤ã‚‹ã', attack: 10, price: 500, type: 'weapon'},
                        {name: 'ã»ã®ãŠã®ã¤ã‚‹ã', attack: 20, price: 2000, type: 'weapon'}
                    ]
                },
                'armor_shop_2': {
                    name: 'ã¼ã†ãã‚„ï¼ˆä¸­ç´šï¼‰',
                    items: [
                        {name: 'ãã•ã‚Šã‹ãŸã³ã‚‰', defense: 10, price: 500, type: 'armor'},
                        {name: 'ã¦ã¤ã®ã‹ã¶ã¨', defense: 3, price: 120, type: 'helmet'}
                    ]
                },
                'inn': {
                    name: 'ã‚„ã©ã‚„',
                    price: 50
                }
            },

            init() {
                this.initAudio();
                this.generateMap();
                this.ensurePlayerStartOnGrass();
                this.updatePlayerPosition();
                this.updateStatus();
                document.addEventListener('keydown', (e) => this.handleInput(e));
                this.playFieldMusic();
            },

            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            },

            createTone(frequency, duration, volume = 0.1, type = 'sine') {
                if (!this.audioContext) return null;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                return { oscillator, gainNode, duration };
            },

            playFieldMusic() {
                if (!this.audioContext || !this.musicEnabled) return;
                this.stopMusic();
                const melody = [
                    // ãƒ•ãƒ¬ãƒ¼ã‚º1
                    {freq: 523.25, dur: 0.3, vol: 0.07}, // C5
                    {freq: 587.33, dur: 0.3, vol: 0.07}, // D5
                    {freq: 659.25, dur: 0.3, vol: 0.08}, // E5
                    {freq: 783.99, dur: 0.6, vol: 0.09}, // G5
                    {freq: 880.00, dur: 0.3, vol: 0.08}, // A5
                    {freq: 783.99, dur: 0.3, vol: 0.07}, // G5
                    // ãƒ•ãƒ¬ãƒ¼ã‚º2
                    {freq: 659.25, dur: 0.4, vol: 0.08}, // E5
                    {freq: 587.33, dur: 0.2, vol: 0.07}, // D5
                    {freq: 523.25, dur: 0.6, vol: 0.08}, // C5
                    {freq: 0, dur: 0.2}, // ä¼‘ç¬¦
                    // ãƒ•ãƒ¬ãƒ¼ã‚º3
                    {freq: 659.25, dur: 0.3, vol: 0.08}, // E5
                    {freq: 783.99, dur: 0.3, vol: 0.08}, // G5
                    {freq: 880.00, dur: 0.3, vol: 0.09}, // A5
                    {freq: 1046.50, dur: 0.9, vol: 0.10}, // C6
                    // ãƒ•ãƒ¬ãƒ¼ã‚º4
                    {freq: 880.00, dur: 0.3, vol: 0.08}, // A5
                    {freq: 783.99, dur: 0.3, vol: 0.08}, // G5
                    {freq: 659.25, dur: 0.3, vol: 0.08}, // E5
                    {freq: 587.33, dur: 0.3, vol: 0.07}, // D5
                    {freq: 523.25, dur: 1.2, vol: 0.09}  // C5
                ];
                const bass = [
                    {freq: 261.63, dur: 1.2, vol: 0.05}, // C4
                    {freq: 329.63, dur: 1.2, vol: 0.05}, // E4
                    {freq: 392.00, dur: 1.2, vol: 0.05}, // G4
                    {freq: 261.63, dur: 1.2, vol: 0.05}, // C4
                    {freq: 220.00, dur: 1.2, vol: 0.05}, // A3
                    {freq: 246.94, dur: 1.2, vol: 0.05}  // B3
                ];
                this.currentMusic = { type: 'field', timeouts: [] };
                const playLoop = () => {
                    let time = 0;
                    melody.forEach(note => {
                        if (note.freq > 0) {
                            const timeout = setTimeout(() => {
                                if (this.currentMusic && this.currentMusic.type === 'field') {
                                    const tone = this.createTone(note.freq, note.dur, note.vol, 'triangle');
                                    if (tone) {
                                        tone.oscillator.start();
                                        tone.oscillator.stop(this.audioContext.currentTime + tone.duration);
                                    }
                                }
                            }, time * 1000);
                            this.currentMusic.timeouts.push(timeout);
                        }
                        time += note.dur;
                    });
                    let bassTime = 0;
                    bass.forEach(note => {
                        const timeout = setTimeout(() => {
                            if (this.currentMusic && this.currentMusic.type === 'field') {
                                const tone = this.createTone(note.freq, note.dur, note.vol, 'sine');
                                if (tone) {
                                    tone.oscillator.start();
                                    tone.oscillator.stop(this.audioContext.currentTime + tone.duration);
                                }
                            }
                        }, bassTime * 1000);
                        this.currentMusic.timeouts.push(timeout);
                        bassTime += note.dur;
                    });
                    const loopTimeout = setTimeout(() => {
                        if (this.currentMusic && this.currentMusic.type === 'field') {
                            this.currentMusic.timeouts = [];
                            playLoop();
                        }
                    }, time * 1000);
                    this.currentMusic.timeouts.push(loopTimeout);
                };
                playLoop();
            },

            playBattleMusic() {
                if (!this.audioContext || !this.musicEnabled) return;
                this.stopMusic();
                const melody = [
                    // ã‚¤ãƒ³ãƒˆãƒ­
                    {freq: 493.88, dur: 0.15, vol: 0.09}, // B4
                    {freq: 523.25, dur: 0.15, vol: 0.09}, // C5
                    {freq: 587.33, dur: 0.15, vol: 0.09}, // D5
                    {freq: 659.25, dur: 0.15, vol: 0.10}, // E5
                    // ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ã‚º
                    {freq: 783.99, dur: 0.3, vol: 0.10}, // G5
                    {freq: 783.99, dur: 0.3, vol: 0.10}, // G5
                    {freq: 880.00, dur: 0.6, vol: 0.11}, // A5
                    {freq: 0, dur: 0.1}, // ä¼‘ç¬¦
                    // å±•é–‹éƒ¨
                    {freq: 659.25, dur: 0.3, vol: 0.09}, // E5
                    {freq: 587.33, dur: 0.3, vol: 0.09}, // D5
                    {freq: 523.25, dur: 0.4, vol: 0.10}, // C5
                    {freq: 587.33, dur: 0.2, vol: 0.09}, // D5
                    // ã‚¯ãƒ©ã‚¤ãƒãƒƒã‚¯ã‚¹
                    {freq: 659.25, dur: 0.2, vol: 0.10}, // E5
                    {freq: 783.99, dur: 0.2, vol: 0.11}, // G5
                    {freq: 880.00, dur: 0.4, vol: 0.12}, // A5
                    {freq: 1046.50, dur: 0.8, vol: 0.13}, // C6
                    // çµ‚çµ
                    {freq: 880.00, dur: 0.3, vol: 0.10}, // A5
                    {freq: 783.99, dur: 0.3, vol: 0.10}, // G5
                    {freq: 659.25, dur: 0.6, vol: 0.11}  // E5
                ];
                this.currentMusic = { type: 'battle', timeouts: [] };
                const playLoop = () => {
                    let time = 0;
                    melody.forEach(note => {
                        if (note.freq > 0) {
                            const timeout = setTimeout(() => {
                                if (this.currentMusic && this.currentMusic.type === 'battle') {
                                    const tone = this.createTone(note.freq, note.dur, note.vol, 'sawtooth');
                                    if (tone) {
                                        tone.oscillator.start();
                                        tone.oscillator.stop(this.audioContext.currentTime + tone.duration);
                                    }
                                }
                            }, time * 1000);
                            this.currentMusic.timeouts.push(timeout);
                        }
                        time += note.dur;
                    });
                    const loopTimeout = setTimeout(() => {
                        if (this.currentMusic && this.currentMusic.type === 'battle') {
                            this.currentMusic.timeouts = [];
                            playLoop();
                        }
                    }, time * 1000);
                    this.currentMusic.timeouts.push(loopTimeout);
                };
                playLoop();
            },

            stopMusic() {
                if (this.currentMusic && this.currentMusic.timeouts) {
                    this.currentMusic.timeouts.forEach(timeout => clearTimeout(timeout));
                    this.currentMusic = null;
                }
            },

            ensurePlayerStartOnGrass() {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é–‹å§‹ä½ç½®ãŒæ°´ã‚„å±±ã§ãªã„ã“ã¨ã‚’ç¢ºèª
                while (this.map[this.player.y][this.player.x] === 'water' || 
                       this.map[this.player.y][this.player.x] === 'mountain') {
                    let found = false;
                    for (let radius = 1; radius < 20 && !found; radius++) {
                        for (let dy = -radius; dy <= radius && !found; dy++) {
                            for (let dx = -radius; dx <= radius && !found; dx++) {
                                const newX = this.player.x + dx;
                                const newY = this.player.y + dy;
                                if (newX >= 0 && newX < this.mapSize && 
                                    newY >= 0 && newY < this.mapSize) {
                                    const tile = this.map[newY][newX];
                                    if (tile === 'grass' || tile === 'forest') {
                                        this.player.x = newX;
                                        this.player.y = newY;
                                        found = true;
                                    }
                                }
                            }
                        }
                    }
                    if (!found) {
                        // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯å¼·åˆ¶çš„ã«è‰åŸã«å¤‰æ›´
                        this.map[this.player.y][this.player.x] = 'grass';
                        break;
                    }
                }
            },

            generateMap() {
                const field = document.getElementById('field');
                field.innerHTML = '';
                
                // ãƒãƒƒãƒ—ã‚’è‰åŸã§åˆæœŸåŒ–
                for (let y = 0; y < this.mapSize; y++) {
                    this.map[y] = [];
                    for (let x = 0; x < this.mapSize; x++) {
                        this.map[y][x] = 'grass';
                    }
                }
                
                // æ°´åŸŸã‚’ç”Ÿæˆ
                for (let i = 0; i < 15; i++) {
                    const centerX = Math.floor(Math.random() * this.mapSize);
                    const centerY = Math.floor(Math.random() * this.mapSize);
                    const size = 5 + Math.floor(Math.random() * 10);
                    for (let dy = -size; dy <= size; dy++) {
                        for (let dx = -size; dx <= size; dx++) {
                            if (dx * dx + dy * dy <= size * size) {
                                const nx = centerX + dx;
                                const ny = centerY + dy;
                                if (nx >= 0 && nx < this.mapSize && ny >= 0 && ny < this.mapSize) {
                                    this.map[ny][nx] = 'water';
                                }
                            }
                        }
                    }
                }
                
                // å±±ã‚’ç”Ÿæˆ
                for (let i = 0; i < 20; i++) {
                    const centerX = Math.floor(Math.random() * this.mapSize);
                    const centerY = Math.floor(Math.random() * this.mapSize);
                    const size = 3 + Math.floor(Math.random() * 6);
                    for (let dy = -size; dy <= size; dy++) {
                        for (let dx = -size; dx <= size; dx++) {
                            if (dx * dx + dy * dy <= size * size && this.map[centerY + dy]?.[centerX + dx] === 'grass') {
                                const nx = centerX + dx;
                                const ny = centerY + dy;
                                if (nx >= 0 && nx < this.mapSize && ny >= 0 && ny < this.mapSize) {
                                    this.map[ny][nx] = 'mountain';
                                }
                            }
                        }
                    }
                }
                
                // æ£®ã‚’ç”Ÿæˆ
                for (let i = 0; i < 25; i++) {
                    const centerX = Math.floor(Math.random() * this.mapSize);
                    const centerY = Math.floor(Math.random() * this.mapSize);
                    const size = 4 + Math.floor(Math.random() * 8);
                    for (let dy = -size; dy <= size; dy++) {
                        for (let dx = -size; dx <= size; dx++) {
                            if (dx * dx + dy * dy <= size * size && this.map[centerY + dy]?.[centerX + dx] === 'grass') {
                                const nx = centerX + dx;
                                const ny = centerY + dy;
                                if (nx >= 0 && nx < this.mapSize && ny >= 0 && ny < this.mapSize) {
                                    this.map[ny][nx] = 'forest';
                                }
                            }
                        }
                    }
                }
                
                // ç ‚æ¼ ã‚’ç”Ÿæˆ
                for (let i = 0; i < 10; i++) {
                    const centerX = Math.floor(Math.random() * this.mapSize);
                    const centerY = Math.floor(Math.random() * this.mapSize);
                    const size = 6 + Math.floor(Math.random() * 10);
                    for (let dy = -size; dy <= size; dy++) {
                        for (let dx = -size; dx <= size; dx++) {
                            if (dx * dx + dy * dy <= size * size && this.map[centerY + dy]?.[centerX + dx] === 'grass') {
                                const nx = centerX + dx;
                                const ny = centerY + dy;
                                if (nx >= 0 && nx < this.mapSize && ny >= 0 && ny < this.mapSize) {
                                    this.map[ny][nx] = 'desert';
                                }
                            }
                        }
                    }
                }
                
                // é›ªåŸã‚’ç”Ÿæˆ
                for (let i = 0; i < 8; i++) {
                    const centerX = Math.floor(Math.random() * this.mapSize);
                    const centerY = Math.floor(Math.random() * this.mapSize);
                    const size = 5 + Math.floor(Math.random() * 8);
                    for (let dy = -size; dy <= size; dy++) {
                        for (let dx = -size; dx <= size; dx++) {
                            if (dx * dx + dy * dy <= size * size && this.map[centerY + dy]?.[centerX + dx] === 'grass') {
                                const nx = centerX + dx;
                                const ny = centerY + dy;
                                if (nx >= 0 && nx < this.mapSize && ny >= 0 && ny < this.mapSize) {
                                    this.map[ny][nx] = 'snow';
                                }
                            }
                        }
                    }
                }
                
                // æ²¼åœ°ã‚’ç”Ÿæˆ
                for (let i = 0; i < 12; i++) {
                    const centerX = Math.floor(Math.random() * this.mapSize);
                    const centerY = Math.floor(Math.random() * this.mapSize);
                    const size = 3 + Math.floor(Math.random() * 5);
                    for (let dy = -size; dy <= size; dy++) {
                        for (let dx = -size; dx <= size; dx++) {
                            if (dx * dx + dy * dy <= size * size && this.map[centerY + dy]?.[centerX + dx] === 'grass') {
                                const nx = centerX + dx;
                                const ny = centerY + dy;
                                if (nx >= 0 && nx < this.mapSize && ny >= 0 && ny < this.mapSize) {
                                    this.map[ny][nx] = 'swamp';
                                }
                            }
                        }
                    }
                }
                
                // æ´çªŸã‚’ç”Ÿæˆ
                for (let i = 0; i < 5; i++) {
                    const x = Math.floor(Math.random() * this.mapSize);
                    const y = Math.floor(Math.random() * this.mapSize);
                    if (this.map[y][x] === 'mountain') {
                        this.map[y][x] = 'cave';
                    }
                }
                
                // ç”ºã¨åº—ã‚’é…ç½®ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã‹ã‚‰è¿‘ã„é †ã«é…ç½®ï¼‰
                const buildings = [
                    {x: 50, y: 45, type: 'town'},
                    {x: 48, y: 42, type: 'weapon_shop_1'},  // åˆç´šæ­¦å™¨å±‹ï¼ˆè¿‘ã„ï¼‰
                    {x: 52, y: 42, type: 'armor_shop_1'},   // åˆç´šé˜²å…·å±‹ï¼ˆè¿‘ã„ï¼‰
                    {x: 50, y: 38, type: 'inn'},            // å®¿å±‹ï¼ˆè¿‘ã„ï¼‰
                    {x: 70, y: 30, type: 'weapon_shop_2'},  // ä¸­ç´šæ­¦å™¨å±‹ï¼ˆé ã„ï¼‰
                    {x: 30, y: 70, type: 'armor_shop_2'}    // ä¸­ç´šé˜²å…·å±‹ï¼ˆé ã„ï¼‰
                ];
                buildings.forEach(b => {
                    for (let dy = -3; dy <= 3; dy++) {
                        for (let dx = -3; dx <= 3; dx++) {
                            const nx = b.x + dx;
                            const ny = b.y + dy;
                            if (nx >= 0 && nx < this.mapSize && ny >= 0 && ny < this.mapSize) {
                                this.map[ny][nx] = 'grass';
                            }
                        }
                    }
                    this.map[b.y][b.x] = b.type;
                });
                
                // ã‚¿ã‚¤ãƒ«ã‚’æç”»
                for (let y = 0; y < this.mapSize; y++) {
                    for (let x = 0; x < this.mapSize; x++) {
                        const tile = document.createElement('div');
                        tile.className = 'tile ' + this.map[y][x];
                        field.appendChild(tile);
                    }
                }
                
                this.updateCamera();
            },

            handleInput(e) {
                if (this.inBattle) return;
                const menuOpen = document.getElementById('equipment-menu') && document.getElementById('equipment-menu').style.display === 'block' ||
                                 document.getElementById('shop-menu') && document.getElementById('shop-menu').style.display === 'block' ||
                                 document.getElementById('inn-menu') && document.getElementById('inn-menu').style.display === 'block';
                if (menuOpen) return;
                
                let newX = this.player.x, newY = this.player.y;
                switch(e.key) {
                    case 'ArrowUp': newY--; break;
                    case 'ArrowDown': newY++; break;
                    case 'ArrowLeft': newX--; break;
                    case 'ArrowRight': newX++; break;
                    default: return;
                }
                if (newX >= 0 && newX < this.mapSize && newY >= 0 && newY < this.mapSize) {
                    const tile = this.map[newY][newX];
                    if (tile !== 'water' && tile !== 'mountain') {
                        this.player.x = newX;
                        this.player.y = newY;
                        this.updatePlayerPosition();
                        this.updateCamera();
                        
                        if (tile === 'grass' && Math.random() < 0.15) {
                            if (Math.random() < 0.1) {
                                this.meetNPC();
                            } else {
                                this.startBattle();
                            }
                        } else if (tile === 'forest' && Math.random() < 0.35) {
                            this.startBattle();
                        } else if (tile === 'desert' && Math.random() < 0.2) {
                            this.startBattle();
                        } else if (tile === 'swamp' && Math.random() < 0.3) {
                            this.startBattle();
                        } else if (tile === 'snow' && Math.random() < 0.25) {
                            this.startBattle();
                        } else if (tile === 'cave') {
                            this.showMessage('æ´çªŸã ï¼å¼·æ•µãŒæ½œã‚“ã§ã„ãã†ã ...');
                            if (Math.random() < 0.5) this.startBattle();
                        } else if (tile === 'town') {
                            this.showMessage('ã‚ˆã†ã“ãã€ç”ºã¸ï¼ã“ã“ã¯å®‰å…¨ãªå ´æ‰€ã§ã™ã€‚');
                        } else if (tile.startsWith('weapon_shop') || tile.startsWith('armor_shop')) {
                            this.openShop(tile);
                        } else if (tile === 'inn') {
                            this.openInn();
                        }
                    }
                }
            },

            updateCamera() {
                const container = document.getElementById('field-container');
                const offsetX = Math.min(Math.max(0, this.player.x - Math.floor(this.viewportWidth / 2)), this.mapSize - this.viewportWidth);
                const offsetY = Math.min(Math.max(0, this.player.y - Math.floor(this.viewportHeight / 2)), this.mapSize - this.viewportHeight);
                container.style.transform = `translate(-${offsetX * 30}px, -${offsetY * 30}px)`;
            },

            updatePlayerPosition() {
                const player = document.getElementById('player');
                const viewCenterX = Math.floor(this.viewportWidth / 2);
                const viewCenterY = Math.floor(this.viewportHeight / 2);
                
                let displayX = viewCenterX;
                let displayY = viewCenterY;
                
                // ãƒãƒƒãƒ—ã®ç«¯ã«ã„ã‚‹å ´åˆã®èª¿æ•´
                if (this.player.x < viewCenterX) {
                    displayX = this.player.x;
                } else if (this.player.x >= this.mapSize - viewCenterX) {
                    displayX = this.viewportWidth - (this.mapSize - this.player.x);
                }
                
                if (this.player.y < viewCenterY) {
                    displayY = this.player.y;
                } else if (this.player.y >= this.mapSize - viewCenterY) {
                    displayY = this.viewportHeight - (this.mapSize - this.player.y);
                }
                
                player.style.left = displayX * 30 + 'px';
                player.style.top = displayY * 30 + 'px';
                
                // ãƒ¬ãƒ™ãƒ«ã«ã‚ˆã£ã¦è¦‹ãŸç›®ã‚’å¤‰æ›´
                if (this.player.level >= 10) {
                    player.style.background = 'linear-gradient(135deg, #ffd700, #ffed4e)';
                    player.style.boxShadow = '0 0 15px rgba(255,215,0,0.8)';
                } else if (this.player.level >= 7) {
                    player.style.background = 'linear-gradient(135deg, #ff6b6b, #ffd700)';
                    player.style.boxShadow = '0 0 12px rgba(255,107,107,0.7)';
                } else if (this.player.level >= 4) {
                    player.style.background = 'linear-gradient(135deg, #4ecdc4, #44a5ff)';
                    player.style.boxShadow = '0 0 10px rgba(78,205,196,0.6)';
                } else {
                    player.style.background = '#ff0';
                    player.style.boxShadow = '0 0 10px rgba(255,255,0,0.5)';
                }
            },

            startBattle() {
                this.inBattle = true;
                this.commandsLocked = false;
                const pool = this.player.level <= 5 ? this.enemies.slice(0, 5) : this.enemies.slice(5, 11);
                const numEnemies = Math.floor(Math.random() * 4) + 1;
                this.currentEnemies = [];
                for (let i = 0; i < numEnemies; i++) {
                    const enemy = JSON.parse(JSON.stringify(pool[Math.floor(Math.random() * pool.length)]));
                    enemy.id = i;
                    enemy.asleep = false;
                    this.currentEnemies.push(enemy);
                }
                this.selectedEnemyIndex = 0;
                document.getElementById('field-container').style.display = 'none';
                document.getElementById('player').style.display = 'none';
                document.getElementById('battle-screen').style.display = 'flex';
                document.getElementById('battle-commands').style.display = 'grid';
                document.getElementById('magic-menu').style.display = 'none';
                document.getElementById('item-menu').style.display = 'none';
                this.renderEnemies();
                const names = this.currentEnemies.length > 1 ? `${this.currentEnemies[0].name}ãŸã¡` : this.currentEnemies[0].name;
                this.showMessage(`${names}ãŒã‚ã‚‰ã‚ã‚ŒãŸï¼`);
                this.updateBattleInfo();
                this.unlockCommands();
                this.playBattleMusic();
            },

            meetNPC() {
                const npc = this.npcs[Math.floor(Math.random() * this.npcs.length)];
                this.inBattle = true;
                document.getElementById('field-container').style.display = 'none';
                document.getElementById('player').style.display = 'none';
                document.getElementById('battle-screen').style.display = 'flex';
                document.getElementById('battle-commands').style.display = 'none';
                document.getElementById('enemy-group').innerHTML = `<div style="font-size:80px">${npc.sprite}</div>`;
                document.getElementById('battle-info').innerHTML = `<div style="font-size:18px;margin:20px;">${npc.name}: ã€Œ${npc.message}ã€</div><button onclick="game.leaveNPC()" style="margin-top:20px;padding:15px 30px;">ã‚ã‹ã£ãŸ</button>`;
            },

            leaveNPC() {
                this.endBattle();
            },

            renderEnemies() {
                const group = document.getElementById('enemy-group');
                group.innerHTML = '';
                this.currentEnemies.forEach((enemy, i) => {
                    const container = document.createElement('div');
                    container.className = 'enemy-container';
                    if (enemy.hp <= 0) {
                        container.classList.add('dead');
                        // å€’ã‚ŒãŸæ•µã¯ã‚¯ãƒªãƒƒã‚¯ä¸å¯
                    } else {
                        if (i === this.selectedEnemyIndex) container.classList.add('selected');
                        container.onclick = () => {
                            this.selectedEnemyIndex = i;
                            this.renderEnemies();
                        };
                    }
                    
                    const sprite = document.createElement('div');
                    sprite.className = 'enemy-sprite';
                    sprite.textContent = enemy.sprite;
                    const number = document.createElement('div');
                    number.className = 'enemy-number';
                    number.textContent = this.currentEnemies.length > 1 ? String.fromCharCode(65 + i) : '';
                    container.appendChild(sprite);
                    container.appendChild(number);
                    group.appendChild(container);
                });
            },

            updateBattleInfo() {
                const alive = this.currentEnemies.filter(e => e.hp > 0);
                let info = alive.map((e, i) => {
                    const idx = this.currentEnemies.indexOf(e);
                    const letter = alive.length > 1 ? String.fromCharCode(65 + idx) + ': ' : '';
                    return letter + e.name;
                }).join('<br>');
                if (this.player.poisoned) info += '<div class="status-effect">ã©ãçŠ¶æ…‹ï¼</div>';
                document.getElementById('battle-info').innerHTML = info;
            },

            attack() {
                if (this.commandsLocked) return;
                const target = this.currentEnemies[this.selectedEnemyIndex];
                if (!target || target.hp <= 0) {
                    this.showMessage('ãã®æ•µã¯ã‚‚ã†ã„ãªã„ï¼');
                    return;
                }
                this.lockCommands();
                const totalAttack = this.player.attack + this.getTotalEquipmentStat('attack');
                const damage = Math.max(1, totalAttack - target.defense + Math.floor(Math.random() * 3));
                target.hp = Math.max(0, target.hp - damage);
                this.showMessage(`${target.name}ã«${damage}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
                this.renderEnemies();
                this.updateBattleInfo();
                
                // å€’ã—ãŸæ•µã‚’é¸æŠã—ã¦ã„ãŸå ´åˆã€æ¬¡ã®ç”Ÿãã¦ã„ã‚‹æ•µã‚’é¸æŠ
                if (target.hp <= 0) {
                    this.selectNextAliveEnemy();
                }
                
                if (this.checkAllDead()) {
                    setTimeout(() => this.winBattle(), 1000);
                } else {
                    setTimeout(() => {
                        this.enemiesAttack();
                    }, 1000);
                }
            },

            selectNextAliveEnemy() {
                // ç¾åœ¨é¸æŠä¸­ã®æ•µãŒå€’ã‚Œã¦ã„ã‚‹å ´åˆã€æ¬¡ã®ç”Ÿãã¦ã„ã‚‹æ•µã‚’é¸æŠ
                for (let i = 0; i < this.currentEnemies.length; i++) {
                    if (this.currentEnemies[i].hp > 0) {
                        this.selectedEnemyIndex = i;
                        this.renderEnemies();
                        return;
                    }
                }
            },

            openMagicMenu() {
                if (this.commandsLocked) return;
                document.getElementById('battle-commands').style.display = 'none';
                document.getElementById('magic-menu').style.display = 'block';
            },

            closeMagicMenu() {
                document.getElementById('magic-menu').style.display = 'none';
                document.getElementById('battle-commands').style.display = 'grid';
            },

            openItemMenu() {
                if (this.commandsLocked) return;
                const list = document.getElementById('item-list');
                list.innerHTML = '';
                for (let item in this.player.inventory) {
                    if (this.player.inventory[item] > 0) {
                        const div = document.createElement('div');
                        div.className = 'shop-item';
                        div.innerHTML = `${item} Ã— ${this.player.inventory[item]}`;
                        div.onclick = () => this.useItem(item);
                        list.appendChild(div);
                    }
                }
                document.getElementById('battle-commands').style.display = 'none';
                document.getElementById('item-menu').style.display = 'block';
            },

            closeItemMenu() {
                document.getElementById('item-menu').style.display = 'none';
                document.getElementById('battle-commands').style.display = 'grid';
            },

            useItem(item) {
                if (this.player.inventory[item] <= 0) return;
                this.player.inventory[item]--;
                this.closeItemMenu();
                this.lockCommands();
                if (item === 'ã‚„ããã†') {
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + 30);
                    this.showMessage('ã‚„ããã†ã‚’ä½¿ã£ãŸï¼HPãŒ30å›å¾©ï¼');
                } else if (item === 'ã©ãã‘ã—ãã†') {
                    this.player.poisoned = false;
                    this.showMessage('ã©ãã‘ã—ãã†ã‚’ä½¿ã£ãŸï¼ã©ããŒæ²»ã£ãŸï¼');
                }
                this.updateStatus();
                setTimeout(() => {
                    this.enemiesAttack();
                }, 1500);
            },

            runAway() {
                if (this.commandsLocked) return;
                this.lockCommands();
                if (Math.random() < 0.7) {
                    this.showMessage('ã†ã¾ãã«ã’ãã£ãŸï¼');
                    setTimeout(() => {
                        this.endBattle();
                    }, 1500);
                } else {
                    this.showMessage('ã«ã’ã‚‰ã‚Œãªã‹ã£ãŸï¼');
                    setTimeout(() => {
                        this.enemiesAttack();
                    }, 1000);
                }
            },

            enemiesAttack() {
                if (!this.inBattle) return;
                const alive = this.currentEnemies.filter(e => e.hp > 0);
                if (alive.length === 0) return;
                
                let idx = 0;
                const attackSeq = () => {
                    if (idx >= alive.length) {
                        // å…¨ã¦ã®æ•µã®æ”»æ’ƒãŒçµ‚äº†
                        setTimeout(() => {
                            this.showMessage('ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ï¼');
                            this.unlockCommands();
                        }, 1000);
                        return;
                    }
                    const enemy = alive[idx];
                    const totalDefense = this.player.defense + this.getTotalEquipmentStat('defense');
                    const damage = Math.max(1, enemy.attack - totalDefense + Math.floor(Math.random() * 2));
                    this.player.hp = Math.max(0, this.player.hp - damage);
                    this.updateStatus();
                    let msg = `${enemy.name}ã®ã“ã†ã’ãï¼<br>${damage}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`;
                    if (enemy.poison && !this.player.poisoned && Math.random() < 0.3) {
                        this.player.poisoned = true;
                        msg += '<br>ã©ãçŠ¶æ…‹ã«ãªã£ãŸï¼';
                    }
                    this.showMessage(msg);
                    this.updateBattleInfo();
                    if (this.player.hp <= 0) {
                        setTimeout(() => this.gameOver(), 1500);
                        return;
                    }
                    idx++;
                    if (idx < alive.length) {
                        setTimeout(attackSeq, 1500);
                    } else {
                        // æœ€å¾Œã®æ•µã®æ”»æ’ƒå¾Œ
                        setTimeout(() => {
                            this.showMessage('ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ï¼');
                            this.unlockCommands();
                        }, 1000);
                    }
                };
                setTimeout(attackSeq, 500);
            },

            checkAllDead() {
                return this.currentEnemies.every(e => e.hp <= 0);
            },

            winBattle() {
                let totalExp = 0;
                let totalGold = 0;
                let drops = [];
                
                this.currentEnemies.forEach(enemy => {
                    totalExp += enemy.exp;
                    totalGold += enemy.gold;
                    
                    // ãƒ‰ãƒ­ãƒƒãƒ—åˆ¤å®š
                    if (enemy.drops) {
                        enemy.drops.forEach(drop => {
                            if (Math.random() < drop.chance) {
                                if (drop.item === 'gold') {
                                    totalGold += drop.amount;
                                    drops.push(`${drop.amount}ã‚´ãƒ¼ãƒ«ãƒ‰`);
                                } else if (drop.type) {
                                    // è£…å‚™å“
                                    this.player.equipment[drop.type] = {
                                        name: drop.item,
                                        attack: drop.attack,
                                        defense: drop.defense
                                    };
                                    drops.push(drop.item);
                                } else {
                                    // ã‚¢ã‚¤ãƒ†ãƒ 
                                    if (!this.player.inventory[drop.item]) {
                                        this.player.inventory[drop.item] = 0;
                                    }
                                    this.player.inventory[drop.item]++;
                                    drops.push(drop.item);
                                }
                            }
                        });
                    }
                });
                
                this.player.exp += totalExp;
                this.player.gold += totalGold;
                
                let message = `å‹åˆ©ï¼<br>çµŒé¨“å€¤${totalExp}ã¨${totalGold}ã‚´ãƒ¼ãƒ«ãƒ‰ç²å¾—ï¼`;
                if (drops.length > 0) {
                    message += `<br>${drops.join('ã€')}ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼`;
                }
                
                this.showMessage(message);
                this.checkLevelUp();
                this.endBattle();
            },

            checkLevelUp() {
                const needed = this.player.level * 20;
                if (this.player.exp >= needed) {
                    this.player.level++;
                    this.player.exp = 0;
                    this.player.maxHp += 10;
                    this.player.hp = this.player.maxHp;
                    this.player.maxMp += 5;
                    this.player.mp = this.player.maxMp;
                    this.player.attack += 2;
                    this.player.defense += 1;
                    setTimeout(() => {
                        this.showMessage(`ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼<br>ãƒ¬ãƒ™ãƒ«${this.player.level}ã«ãªã£ãŸï¼`);
                    }, 1500);
                    this.updateStatus();
                }
            },

            gameOver() {
                this.showMessage('ã‚ãªãŸã¯ã—ã‚“ã§ã—ã¾ã£ãŸ...<br>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼');
                setTimeout(() => {
                    this.player.hp = this.player.maxHp;
                    this.player.mp = this.player.maxMp;
                    this.player.gold = Math.floor(this.player.gold / 2);
                    this.player.poisoned = false;
                    this.updateStatus();
                    this.endBattle();
                }, 3000);
            },

            endBattle() {
                setTimeout(() => {
                    this.inBattle = false;
                    this.commandsLocked = false;
                    this.player.poisoned = false;
                    document.getElementById('battle-screen').style.display = 'none';
                    document.getElementById('field-container').style.display = 'block';
                    document.getElementById('player').style.display = 'block';
                    this.unlockCommands();
                    this.showMessage('å†’é™ºã‚’ã¤ã¥ã‘ã‚ˆã†ï¼');
                    this.playFieldMusic();
                }, 2000);
            },

            openShop(shopType) {
                const shop = this.shops[shopType];
                if (!shop) return;
                this.currentShop = shopType;
                const menu = document.getElementById('shop-menu');
                const title = document.getElementById('shop-title');
                const itemsDiv = document.getElementById('shop-items');
                
                title.textContent = shop.name;
                itemsDiv.innerHTML = '';
                
                shop.items.forEach((item, i) => {
                    const div = document.createElement('div');
                    div.className = 'shop-item';
                    const stat = item.attack ? `æ”»+${item.attack}` : `å®ˆ+${item.defense}`;
                    div.innerHTML = `<span>${item.name} (${stat})</span><span>${item.price}G</span>`;
                    div.onclick = () => this.buyItem(item);
                    itemsDiv.appendChild(div);
                });
                
                menu.style.display = 'block';
            },

            buyItem(item) {
                if (this.player.gold >= item.price) {
                    this.player.gold -= item.price;
                    this.player.equipment[item.type] = item;
                    this.updateStatus();
                    alert(`${item.name}ã‚’ã‹ã£ãŸï¼`);
                } else {
                    alert('ãŠã‹ã­ãŒãŸã‚Šãªã„ï¼');
                }
            },

            closeShop() {
                document.getElementById('shop-menu').style.display = 'none';
                this.currentShop = null;
            },

            openInn() {
                document.getElementById('inn-menu').style.display = 'block';
            },

            closeInn() {
                document.getElementById('inn-menu').style.display = 'none';
            },

            stayAtInn() {
                const price = this.shops.inn.price;
                if (this.player.gold >= price) {
                    this.player.gold -= price;
                    this.player.hp = this.player.maxHp;
                    this.player.mp = this.player.maxMp;
                    this.player.poisoned = false;
                    this.updateStatus();
                    alert(`ã‚†ã£ãã‚Šä¼‘ã‚“ã ã€‚\nHPã¨MPãŒå…¨å›å¾©ã—ãŸï¼`);
                    this.closeInn();
                } else {
                    alert('ãŠã‹ã­ãŒãŸã‚Šãªã„ï¼');
                }
            },

            getTotalEquipmentStat(stat) {
                let total = 0;
                for (let slot in this.player.equipment) {
                    const item = this.player.equipment[slot];
                    if (item && item[stat]) {
                        total += item[stat];
                    }
                }
                return total;
            },

            lockCommands() {
                this.commandsLocked = true;
                document.querySelectorAll('#battle-commands button').forEach(b => b.disabled = true);
            },

            unlockCommands() {
                if (!this.inBattle) return;
                this.commandsLocked = false;
                document.querySelectorAll('#battle-commands button').forEach(b => b.disabled = false);
            },

            showMessage(msg) {
                document.getElementById('message-box').innerHTML = msg;
            },

            updateStatus() {
                document.getElementById('level').textContent = this.player.level;
                document.getElementById('hp').textContent = this.player.hp;
                document.getElementById('maxHp').textContent = this.player.maxHp;
                document.getElementById('mp').textContent = this.player.mp;
                document.getElementById('maxMp').textContent = this.player.maxMp;
                document.getElementById('exp').textContent = this.player.exp;
                document.getElementById('gold').textContent = this.player.gold;
            }
        };

        window.onload = () => game.init();
    </script>
</body>
</html>